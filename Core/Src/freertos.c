/* USER CODE BEGIN Header */
/**
 * @file freertos.c
 * @author Tiantian Zhong (giant@zju.edu.cn)
 * @brief FreeRTOS initialization and tasks.
 *        This file is modified based on the original freertos.c file generated by STM32CubeMX.
 * @date 2024-05-11
 *
 * @copyright Copyright (c) 2024 Tiantian Zhong @ Zhejiang University
 *          This file is part of ZJUI ECE 445 Spring 2024 Project 19.
 *
 */
/* USER CODE END Header */

/* Includes ------------------------------------------------------------------*/
#include "FreeRTOS.h"
#include "cmsis_os.h"
#include "main.h"
#include "task.h"

/* Private includes ----------------------------------------------------------*/
/* USER CODE BEGIN Includes */
// peripherals
#include "adc.h"
#include "esp.h"
#include "lcd.h"
#include "os_events.h"
#include "queue.h"
#include "usart.h"
#include <stdio.h>
#include <string.h>

/* USER CODE END Includes */

/* Private typedef -----------------------------------------------------------*/
/* USER CODE BEGIN PTD */

/* USER CODE END PTD */

/* Private define ------------------------------------------------------------*/
/* USER CODE BEGIN PD */
#define OVERLOAD_LIMIT 3.           // in A
#define UNDERLOAD_VOLTAGE_LIMIT 2.5 // in V
/* USER CODE END PD */

/* Private macro -------------------------------------------------------------*/
/* USER CODE BEGIN PM */

/* USER CODE END PM */

/* Private variables ---------------------------------------------------------*/
/* USER CODE BEGIN Variables */
extern uint8_t os_running;

// ADC data buffer
extern uint32_t adc1_data[4];

// ADC current sensor voltage base
extern float adc_current_base_mmc, adc_current_base_bkup;

// Power data
sysPwrData_t sys_pwr = {0};

/* USER CODE END Variables */
/* Definitions for pwr_monitor */
osThreadId_t pwr_monitorHandle;
const osThreadAttr_t pwr_monitor_attributes = {
    .name = "pwr_monitor",
    .stack_size = 1050 * 4,
    .priority = (osPriority_t)osPriorityNormal,
};
/* Definitions for esp_msg */
osThreadId_t esp_msgHandle;
const osThreadAttr_t esp_msg_attributes = {
    .name = "esp_msg",
    .stack_size = 1050 * 4,
    .priority = (osPriority_t)osPriorityNormal,
};
/* Definitions for led_blink */
osThreadId_t led_blinkHandle;
const osThreadAttr_t led_blink_attributes = {
    .name = "led_blink",
    .stack_size = 128 * 4,
    .priority = (osPriority_t)osPriorityNormal,
};
/* Definitions for mqtt_msg */
osThreadId_t mqtt_msgHandle;
const osThreadAttr_t mqtt_msg_attributes = {
    .name = "mqtt_msg",
    .stack_size = 1050 * 4,
    .priority = (osPriority_t)osPriorityNormal,
};
/* Definitions for report_stat */
osThreadId_t report_statHandle;
const osThreadAttr_t report_stat_attributes = {
    .name = "report_stat",
    .stack_size = 1050 * 4,
    .priority = (osPriority_t)osPriorityNormal,
};
/* Definitions for esp_rx_queue */
osMessageQueueId_t esp_rx_queueHandle;
const osMessageQueueAttr_t esp_rx_queue_attributes = {.name = "esp_rx_queue"};
/* Definitions for esp_tx_queue */
osMessageQueueId_t esp_tx_queueHandle;
const osMessageQueueAttr_t esp_tx_queue_attributes = {.name = "esp_tx_queue"};
/* Definitions for usr_cmd_queue */
osMessageQueueId_t usr_cmd_queueHandle;
const osMessageQueueAttr_t usr_cmd_queue_attributes = {.name = "usr_cmd_queue"};
/* Definitions for report_pwr_queue */
osMessageQueueId_t report_pwr_queueHandle;
const osMessageQueueAttr_t report_pwr_queue_attributes = {.name = "report_pwr_queue"};
/* Definitions for mqtt_rx_msg_queue */
osMessageQueueId_t mqtt_rx_msg_queueHandle;
const osMessageQueueAttr_t mqtt_rx_msg_queue_attributes = {.name = "mqtt_rx_msg_queue"};
/* Definitions for tmr_report_pwr */
osTimerId_t tmr_report_pwrHandle;
const osTimerAttr_t tmr_report_pwr_attributes = {.name = "tmr_report_pwr"};
/* Definitions for adc_mutex */
osMutexId_t adc_mutexHandle;
const osMutexAttr_t adc_mutex_attributes = {.name = "adc_mutex"};
/* Definitions for lcd_mutex */
osMutexId_t lcd_mutexHandle;
const osMutexAttr_t lcd_mutex_attributes = {.name = "lcd_mutex"};
/* Definitions for sys_stat */
osEventFlagsId_t sys_statHandle;
const osEventFlagsAttr_t sys_stat_attributes = {.name = "sys_stat"};
/* Definitions for state_machine */
osEventFlagsId_t state_machineHandle;
const osEventFlagsAttr_t state_machine_attributes = {.name = "state_machine"};

/* Private function prototypes -----------------------------------------------*/
/* USER CODE BEGIN FunctionPrototypes */
extern uint8_t eb_scan();
/* USER CODE END FunctionPrototypes */

void pwr_monitor_tsk(void *argument);
extern void esp_msg_tsk(void *argument);
void led_blink_tsk(void *argument);
extern void mqtt_msg_tsk(void *argument);
void sys_stat_tsk(void *argument);
extern void tmr_report_pwr_clbk(void *argument);

void MX_FREERTOS_Init(void); /* (MISRA C 2004 rule 8.1) */

/**
 * @brief  FreeRTOS initialization
 * @param  None
 * @retval None
 */
void MX_FREERTOS_Init(void)
{
    /* USER CODE BEGIN Init */
    os_running = 1;
    /* USER CODE END Init */
    /* Create the mutex(es) */
    /* creation of adc_mutex */
    adc_mutexHandle = osMutexNew(&adc_mutex_attributes);

    /* creation of lcd_mutex */
    lcd_mutexHandle = osMutexNew(&lcd_mutex_attributes);

    /* USER CODE BEGIN RTOS_MUTEX */
    /* add mutexes, ... */
    /* USER CODE END RTOS_MUTEX */

    /* USER CODE BEGIN RTOS_SEMAPHORES */
    /* add semaphores, ... */
    /* USER CODE END RTOS_SEMAPHORES */

    /* Create the timer(s) */
    /* creation of tmr_report_pwr */
    tmr_report_pwrHandle = osTimerNew(tmr_report_pwr_clbk, osTimerPeriodic, NULL, &tmr_report_pwr_attributes);

    /* USER CODE BEGIN RTOS_TIMERS */
    /* start timers, add new ones, ... */
    /* USER CODE END RTOS_TIMERS */

    /* Create the queue(s) */
    /* creation of esp_rx_queue */
    esp_rx_queueHandle = osMessageQueueNew(8, 255, &esp_rx_queue_attributes);

    /* creation of esp_tx_queue */
    esp_tx_queueHandle = osMessageQueueNew(8, 255, &esp_tx_queue_attributes);

    /* creation of usr_cmd_queue */
    usr_cmd_queueHandle = osMessageQueueNew(2, 6, &usr_cmd_queue_attributes);

    /* creation of report_pwr_queue */
    report_pwr_queueHandle = osMessageQueueNew(1, 50, &report_pwr_queue_attributes);

    /* creation of mqtt_rx_msg_queue */
    mqtt_rx_msg_queueHandle = osMessageQueueNew(4, 255, &mqtt_rx_msg_queue_attributes);

    /* USER CODE BEGIN RTOS_QUEUES */
    /* add queues, ... */
    /* USER CODE END RTOS_QUEUES */

    /* Create the thread(s) */
    /* creation of pwr_monitor */
    pwr_monitorHandle = osThreadNew(pwr_monitor_tsk, NULL, &pwr_monitor_attributes);

    /* creation of esp_msg */
    esp_msgHandle = osThreadNew(esp_msg_tsk, NULL, &esp_msg_attributes);

    /* creation of led_blink */
    led_blinkHandle = osThreadNew(led_blink_tsk, NULL, &led_blink_attributes);

    /* creation of mqtt_msg */
    mqtt_msgHandle = osThreadNew(mqtt_msg_tsk, NULL, &mqtt_msg_attributes);

    /* creation of report_stat */
    report_statHandle = osThreadNew(sys_stat_tsk, NULL, &report_stat_attributes);

    /* USER CODE BEGIN RTOS_THREADS */
    /* add threads, ... */
    /* USER CODE END RTOS_THREADS */

    /* creation of sys_stat */
    sys_statHandle = osEventFlagsNew(&sys_stat_attributes);

    /* creation of state_machine */
    state_machineHandle = osEventFlagsNew(&state_machine_attributes);

    /* USER CODE BEGIN RTOS_EVENTS */
    /* USER CODE END RTOS_EVENTS */
}

/* USER CODE BEGIN Header_pwr_monitor_tsk */
/**
 * @brief  Function implementing the pwr_monitor thread.
 * @param  argument: Not used
 * @retval None
 */
/* USER CODE END Header_pwr_monitor_tsk */
void pwr_monitor_tsk(void *argument)
{
    /* USER CODE BEGIN pwr_monitor_tsk */
    uint32_t adc_value_buff[6];
    uint32_t adc_value_accumulate[6];
    uint8_t eb_handled = 0;
    uint8_t ovld_handled = 0;
    uint8_t udld_handled = 0;
    uint8_t sys_state = 0; // state machine

    uint16_t voltage_backup_cut_in = 0;
    uint16_t voltage_backup_cut_out = 0;
    uint16_t current_limit = 100;
    uint32_t state_machine_flags = 0;

    user_cmd_t user_cmd = {0};
    user_cmd.voltage_backup_cut_in = 10;
    user_cmd.voltage_backup_cut_out = 12;
    user_cmd.current = 10;

    osTimerStart(tmr_report_pwrHandle, 1000);
    osEventFlagsClear(state_machineHandle, 0xFFFFFFU);
    osEventFlagsSet(state_machineHandle, STATE_MACHINE_IDLE);
    HAL_GPIO_WritePin(MMC_EN_GPIO_Port, MMC_EN_Pin, GPIO_PIN_RESET);
    HAL_GPIO_WritePin(BKUP_EN_GPIO_Port, BKUP_EN_Pin, GPIO_PIN_RESET);

    /* Infinite loop */
    for (;;)
    {
        if (eb_scan() && !eb_handled) // EB pressed
        {
            eb_handled = 1;
            HAL_GPIO_WritePin(FAULT_GPIO_Port, FAULT_Pin, GPIO_PIN_SET);

            // cut power
            osEventFlagsClear(sys_statHandle, EVENT_MMC_EN);
            osEventFlagsClear(sys_statHandle, EVENT_BKUP_EN);
            HAL_GPIO_WritePin(MMC_EN_GPIO_Port, MMC_EN_Pin, GPIO_PIN_RESET);
            HAL_GPIO_WritePin(BKUP_EN_GPIO_Port, BKUP_EN_Pin, GPIO_PIN_RESET);

            // set event flags
            osEventFlagsClear(state_machineHandle, 0xFFFFFFU);
            osEventFlagsSet(state_machineHandle, STATE_MACHINE_EB);

            // clear event flags
            osEventFlagsClear(sys_statHandle, EVENT_MMC_EN | EVENT_BKUP_EN | EVENT_UNDRLD);
            osEventFlagsClear(state_machineHandle, STATE_MACHINE_PWR_ROUTING | STATE_MACHINE_PWR_FORCE_PRIMARY |
                                                       STATE_MACHINE_PWR_FORCE_BACKUP);

            // display info on LCD
            osEventFlagsSet(sys_statHandle, EVENT_EB_PRESSED);
            lcd_show_eb();
        }
        if (!eb_scan() && eb_handled) // EB released
        {
            eb_handled = 0;

            // display info
            lcd_show_idle();

            // clear flags
            osEventFlagsClear(sys_statHandle, EVENT_EB_PRESSED);
            osEventFlagsClear(state_machineHandle, STATE_MACHINE_EB);

            // set to idle state
            osEventFlagsClear(state_machineHandle, 0xFFFFFFU);
            osEventFlagsSet(state_machineHandle, STATE_MACHINE_IDLE);
            HAL_GPIO_WritePin(FAULT_GPIO_Port, FAULT_Pin, GPIO_PIN_RESET);
        }

        // update smart power routing voltage parameters and overload current limit parameter
        if (osMessageQueueGet(usr_cmd_queueHandle, &user_cmd, NULL, 0) == osOK)
        {
            if (user_cmd.voltage_backup_cut_in > 0) // -1 means no change
            {
                ovld_handled = 0;
                osEventFlagsClear(sys_statHandle, EVENT_OVERLD);
                voltage_backup_cut_in = user_cmd.voltage_backup_cut_in / 100;
            }
            if (user_cmd.voltage_backup_cut_out > 0) // -1 means no change
            {
                voltage_backup_cut_out = user_cmd.voltage_backup_cut_out / 100;
            }
            current_limit = user_cmd.current / 100;
            lcd_show_normal();
            printf("limits: %d, %d, %d\r\n", voltage_backup_cut_in, voltage_backup_cut_out, current_limit);
            lcd_show_limits(voltage_backup_cut_in, voltage_backup_cut_out, current_limit);
        }

        // get ADC data 20 times
        memset(adc_value_accumulate, 0, sizeof(adc_value_accumulate));
        for (uint8_t i = 0; i < 20; i++)
        {
            // get ADC data
            if (osMutexAcquire(adc_mutexHandle, 0) == osOK)
            {
                memcpy(adc_value_buff, adc1_data, sizeof(adc_value_buff));
                osMutexRelease(adc_mutexHandle);
                for (uint8_t j = 0; j < 6; j++)
                {
                    adc_value_accumulate[j] += adc_value_buff[j];
                }
            }
            osDelay(10);
        }
        // get average ADC data
        for (uint8_t i = 0; i < 6; i++)
        {
            adc_value_buff[i] = adc_value_accumulate[i] / 20;
        }
        // Calculate power data
        sys_pwr.mmc.voltage = adc_value_buff[0] / ADC_COEFFICIENT * ADC_COEFFICIENT_VOLTAGE_MMC;
        sys_pwr.bkup.voltage = adc_value_buff[1] / ADC_COEFFICIENT * ADC_COEFFICIENT_VOLTAGE_BKUP;
        sys_pwr.mmc.current = (adc_current_base_mmc - (adc_value_buff[3] / ADC_COEFFICIENT)) / 0.1;
        sys_pwr.bkup.current = (adc_current_base_bkup - (adc_value_buff[4] / ADC_COEFFICIENT)) / 0.1;
        sys_pwr.mmc.power = sys_pwr.mmc.voltage * sys_pwr.mmc.current;
        sys_pwr.bkup.power = sys_pwr.bkup.voltage * sys_pwr.bkup.current;

        // report power info to lcd and esp8266 (every one second)
        xQueueOverwrite(report_pwr_queueHandle, &sys_pwr);

        //  overload protection
        if ((sys_pwr.mmc.current > current_limit || sys_pwr.bkup.current > current_limit) && !ovld_handled)
        {
            ovld_handled = 1;
            osEventFlagsSet(sys_statHandle, EVENT_OVERLD);

            // cut power
            osEventFlagsClear(sys_statHandle, EVENT_MMC_EN);
            osEventFlagsClear(sys_statHandle, EVENT_BKUP_EN);
            HAL_GPIO_WritePin(MMC_EN_GPIO_Port, MMC_EN_Pin, GPIO_PIN_RESET);
            HAL_GPIO_WritePin(BKUP_EN_GPIO_Port, BKUP_EN_Pin, GPIO_PIN_RESET);

            // display info on LCD
            lcd_show_overload();
            osDelay(50);
            continue;
        }

        state_machine_flags = osEventFlagsGet(state_machineHandle);

        // idle/EB/overload state where power is cut off
        if (state_machine_flags & (STATE_MACHINE_IDLE | STATE_MACHINE_EB | STATE_MACHINE_OVERLD) != 0)
        {
            osEventFlagsClear(sys_statHandle, EVENT_MMC_EN);
            osEventFlagsClear(sys_statHandle, EVENT_BKUP_EN);
            HAL_GPIO_WritePin(MMC_EN_GPIO_Port, MMC_EN_Pin, GPIO_PIN_RESET);
            HAL_GPIO_WritePin(BKUP_EN_GPIO_Port, BKUP_EN_Pin, GPIO_PIN_RESET);
            osDelay(50);
            continue;
        }

        // force backup
        if (state_machine_flags == STATE_MACHINE_PWR_FORCE_BACKUP)
        {
            osEventFlagsClear(sys_statHandle, EVENT_MMC_EN);
            osEventFlagsSet(sys_statHandle, EVENT_BKUP_EN);
            HAL_GPIO_WritePin(MMC_EN_GPIO_Port, MMC_EN_Pin, GPIO_PIN_RESET);
            osDelay(100);
            HAL_GPIO_WritePin(BKUP_EN_GPIO_Port, BKUP_EN_Pin, GPIO_PIN_SET);
            osDelay(50);
            continue;
        }

        // fource mmc
        if (state_machine_flags == STATE_MACHINE_PWR_FORCE_PRIMARY)
        {
            osEventFlagsClear(sys_statHandle, EVENT_BKUP_EN);
            osEventFlagsSet(sys_statHandle, EVENT_MMC_EN);
            HAL_GPIO_WritePin(BKUP_EN_GPIO_Port, BKUP_EN_Pin, GPIO_PIN_RESET);
            osDelay(100);
            HAL_GPIO_WritePin(MMC_EN_GPIO_Port, MMC_EN_Pin, GPIO_PIN_SET);
            osDelay(50);
            continue;
        }

        if (state_machine_flags == STATE_MACHINE_PWR_ROUTING)
        {
            // switch pwr to backup
            if ((sys_pwr.mmc.voltage < voltage_backup_cut_in) && !udld_handled && !ovld_handled)
            {
                // udld_handled = 1;
                osEventFlagsSet(sys_statHandle, EVENT_BKUP_EN);
                osEventFlagsClear(sys_statHandle, EVENT_MMC_EN);

                // switch power
                HAL_GPIO_WritePin(MMC_EN_GPIO_Port, MMC_EN_Pin, GPIO_PIN_RESET);
                osDelay(100);
                HAL_GPIO_WritePin(BKUP_EN_GPIO_Port, BKUP_EN_Pin, GPIO_PIN_SET);
            }

            // switch output back to primary (MMC)
            if (sys_pwr.mmc.voltage > voltage_backup_cut_out && !ovld_handled)
            {
                // udld_handled = 0;
                osEventFlagsSet(sys_statHandle, EVENT_MMC_EN);
                osEventFlagsClear(sys_statHandle, EVENT_BKUP_EN);

                // switch power source
                HAL_GPIO_WritePin(BKUP_EN_GPIO_Port, BKUP_EN_Pin, GPIO_PIN_RESET);
                osDelay(100);
                HAL_GPIO_WritePin(MMC_EN_GPIO_Port, MMC_EN_Pin, GPIO_PIN_SET);
            }
        }
    }
    /* USER CODE END pwr_monitor_tsk */
}

/* USER CODE BEGIN Header_led_blink_tsk */
/**
 * @brief Blink the OS_STAT LED to indicate FreeRTOS is running.
 * @param argument: Not used
 * @retval None
 */
/* USER CODE END Header_led_blink_tsk */
void led_blink_tsk(void *argument)
{
    /* USER CODE BEGIN led_blink_tsk */
    /* Infinite loop */
    HAL_GPIO_WritePin(OS_STAT_GPIO_Port, OS_STAT_Pin, GPIO_PIN_SET);
    for (;;)
    {
        HAL_GPIO_TogglePin(OS_STAT_GPIO_Port, OS_STAT_Pin);
        osDelay(500);
    }
    /* USER CODE END led_blink_tsk */
}

/* USER CODE BEGIN Header_sys_stat_tsk */
/**
 * @brief Function implementing the sys_stat thread.
 * @param argument: Not used
 * @retval None
 */
/* USER CODE END Header_sys_stat_tsk */
void sys_stat_tsk(void *argument)
{
    /* USER CODE BEGIN sys_stat_tsk */
    uint8_t buff[256] = {0};
    uint8_t ovld_sent = 0, eb_sent = 0, normal_sent = 0;
    uint8_t lcd_normal_handled = 0, lcd_bkup_handled = 0;
    uint32_t state_machine_flags = 0;
    /* Infinite loop */
    for (;;)
    {
        state_machine_flags = osEventFlagsGet(state_machineHandle);
        osEventFlagsWait(sys_statHandle, EVENT_MQTT_CONN_STAT, osFlagsNoClear,
                         osWaitForever); // wait for mqtt connection
        if ((state_machine_flags == STATE_MACHINE_OVERLD) && !ovld_sent)
        {
            ovld_sent = 1;
            eb_sent = 0;
            normal_sent = 0;
            sprintf(buff, "AT+MQTTPUB=0,\"%s\",\"%d\",%d,0\r\n", MQTT_TOPIC_WARN, MQTT_WARN_OVERLOAD, MQTT_QOS2);
            osMessageQueuePut(esp_tx_queueHandle, buff, 0, 500);
        }
        else if ((state_machine_flags == STATE_MACHINE_EB) && !eb_sent)
        {
            ovld_sent = 0;
            eb_sent = 1;
            normal_sent = 0;
            sprintf(buff, "AT+MQTTPUB=0,\"%s\",\"%d\",%d,0\r\n", MQTT_TOPIC_WARN, MQTT_WARN_EB_PRESSED, MQTT_QOS2);
            osMessageQueuePut(esp_tx_queueHandle, buff, 0, 500);
        }
        else if ((state_machine_flags == STATE_MACHINE_IDLE) && !normal_sent)
        {
            ovld_sent = 0;
            eb_sent = 0;
            normal_sent = 1;
            sprintf(buff, "AT+MQTTPUB=0,\"%s\",\"%d\",%d,0\r\n", MQTT_TOPIC_WARN, MQTT_WARN_NORMAL, MQTT_QOS2);
            osMessageQueuePut(esp_tx_queueHandle, buff, 0, 500);
        }

        // handle displaying power source
        if ((osEventFlagsGet(sys_statHandle) & EVENT_MMC_EN) && !lcd_normal_handled)
        {
            lcd_normal_handled = 1;
            lcd_bkup_handled = 0;
            lcd_show_normal();
        }
        if ((osEventFlagsGet(sys_statHandle) & EVENT_BKUP_EN) && !lcd_bkup_handled)
        {
            lcd_normal_handled = 0;
            lcd_bkup_handled = 1;
            lcd_show_backup();
        }
        osDelay(10);
    }
    /* USER CODE END sys_stat_tsk */
}

/* Private application code --------------------------------------------------*/
/* USER CODE BEGIN Application */

/* USER CODE END Application */
